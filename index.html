<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Gesture Particles</title>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body { background: #000; font-family: Arial, sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }
        #video { position: absolute; top: 10px; right: 10px; width: 160px; height: 120px; border: 2px solid #fff; border-radius: 8px; z-index: 10; }
        #controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 10; flex-wrap: wrap; justify-content: center; max-width: 90%; }
        .btn { background: rgba(255,255,255,0.2); border: 2px solid #fff; color: #fff; padding: 12px 20px; border-radius: 25px; cursor: pointer; font-size: 14px; backdrop-filter: blur(10px); transition: all 0.3s; }
        .btn:active { transform: scale(0.95); background: rgba(255,255,255,0.3); }
        .btn.active { background: rgba(100,200,255,0.5); border-color: #0af; }
        #info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; font-size: 12px; z-index: 10; max-width: 250px; }
        #gesture { font-size: 16px; font-weight: bold; margin: 8px 0; }
        .gesture-list { font-size: 10px; margin-top: 10px; opacity: 0.7; line-height: 1.4; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 18px; text-align: center; z-index: 100; background: rgba(0,0,0,0.8); padding: 30px; border-radius: 15px; }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Loading Hand Tracking...</div>
        <video id="video" autoplay playsinline></video>
        <div id="info">
            <div>üëã Show your hand to camera</div>
            <div id="gesture">Gesture: None</div>
            <div id="fps">FPS: 0</div>
            <div class="gesture-list">
                ‚úåÔ∏èPeace ‚Ä¢ ü§òRock ‚Ä¢ üëåOK<br>
                üëçThumbs ‚Ä¢ ‚úäFist ‚Ä¢ üëâPoint<br>
                ü§èPinch ‚Ä¢ ‚úãSpread
            </div>
        </div>
        <div id="controls">
            <button class="btn" data-shape="sphere">Sphere</button>
            <button class="btn active" data-shape="heart">Heart</button>
            <button class="btn" data-shape="flower">Flower</button>
            <button class="btn" data-shape="saturn">Saturn</button>
            <button class="btn" data-shape="firework">Firework</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script>
        const videoElement = document.getElementById('video');
        const loadingElement = document.getElementById('loading');
        const gestureElement = document.getElementById('gesture');
        const fpsElement = document.getElementById('fps');
        
        let scene, camera, renderer, particles, particleSystem;
        let handData = { detected: false, x: 0, y: 0, z: 0, pinch: 0, spread: 0 };
        let currentShape = 'heart';
        let targetScale = 1;
        let currentScale = 1;
        let colorHue = 0;

        const PARTICLE_COUNT = 5000;
        
        // Initialize Three.js
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);
            
            createParticleSystem();
            animate();
        }

        // Particle shape generators
        function generateShape(shape, count) {
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                let x, y, z, h;
                const i3 = i * 3;
                
                switch(shape) {
                    case 'heart':
                        const t = (i / count) * Math.PI * 2;
                        const u = Math.random() * 0.5;
                        x = u * (16 * Math.pow(Math.sin(t), 3)) * 0.05;
                        y = u * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.05;
                        z = (Math.random() - 0.5) * 0.5;
                        h = 0.95;
                        break;
                        
                    case 'flower':
                        const angle = (i / count) * Math.PI * 2 * 5;
                        const r = Math.random() * (0.5 + 0.3 * Math.sin(angle * 6));
                        x = r * Math.cos(angle);
                        y = r * Math.sin(angle);
                        z = (Math.random() - 0.5) * 0.3;
                        h = (i / count) * 0.3 + 0.5;
                        break;
                        
                    case 'saturn':
                        const phi = Math.random() * Math.PI * 2;
                        const theta = Math.random() * Math.PI;
                        const dist = Math.random() < 0.3 ? Math.random() * 2 : Math.random() * 0.6;
                        const isSphere = Math.random() < 0.3;
                        
                        if (isSphere) {
                            x = dist * Math.sin(theta) * Math.cos(phi) * 0.5;
                            y = dist * Math.sin(theta) * Math.sin(phi) * 0.5;
                            z = dist * Math.cos(theta) * 0.5;
                        } else {
                            x = dist * Math.cos(phi);
                            y = (Math.random() - 0.5) * 0.1;
                            z = dist * Math.sin(phi);
                        }
                        h = 0.55;
                        break;
                        
                    case 'firework':
                        const burst = Math.random();
                        const direction = Math.random() * Math.PI * 2;
                        const elevation = Math.random() * Math.PI;
                        const speed = burst * 2;
                        x = speed * Math.sin(elevation) * Math.cos(direction);
                        y = speed * Math.sin(elevation) * Math.sin(direction);
                        z = speed * Math.cos(elevation);
                        h = burst * 0.8;
                        break;
                        
                    default: // sphere
                        const p = Math.random() * Math.PI * 2;
                        const th = Math.random() * Math.PI;
                        const rd = Math.random() * 1.5;
                        x = rd * Math.sin(th) * Math.cos(p);
                        y = rd * Math.sin(th) * Math.sin(p);
                        z = rd * Math.cos(th);
                        h = Math.random();
                }
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                const color = new THREE.Color().setHSL(h, 0.8, 0.6);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            
            return { positions, colors };
        }

        function createParticleSystem() {
            if (particleSystem) {
                scene.remove(particleSystem);
            }
            
            const { positions, colors } = generateShape(currentShape, PARTICLE_COUNT);
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            particles = positions;
        }

        // MediaPipe Hands setup
        async function initHandTracking() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user', width: 640, height: 480 } 
                });
                videoElement.srcObject = stream;
                
                await new Promise(resolve => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        resolve();
                    };
                });
                
                setupMediaPipe();
                
            } catch (err) {
                console.error('Camera error:', err);
                loadingElement.textContent = 'Camera access denied. Please enable camera permissions.';
            }
        }

        function setupMediaPipe() {
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults(onHandResults);
            
            const cam = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });
            cam.start();
            
            loadingElement.style.display = 'none';
        }

        let currentGesture = 'none';
        let gestureStartTime = 0;
        let rotationSpeed = 0.002;
        let explosionActive = false;

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const thumb = landmarks[4];
                const index = landmarks[8];
                const middle = landmarks[12];
                const ring = landmarks[16];
                const pinky = landmarks[20];
                const wrist = landmarks[0];
                
                handData.detected = true;
                handData.x = (landmarks[9].x - 0.5) * 4;
                handData.y = -(landmarks[9].y - 0.5) * 3;
                handData.z = -landmarks[9].z * 5;
                
                // Calculate pinch (thumb-index distance)
                const pinchDist = Math.sqrt(
                    Math.pow(thumb.x - index.x, 2) +
                    Math.pow(thumb.y - index.y, 2)
                );
                handData.pinch = Math.max(0, 1 - pinchDist * 10);
                
                // Calculate spread (finger spread)
                const spread = Math.abs(index.x - pinky.x) + Math.abs(index.y - pinky.y);
                handData.spread = Math.min(spread * 3, 1);
                
                // Finger tip heights (y position)
                const thumbTip = thumb.y;
                const indexTip = index.y;
                const middleTip = middle.y;
                const ringTip = ring.y;
                const pinkyTip = pinky.y;
                
                // Count extended fingers
                const indexUp = indexTip < landmarks[6].y;
                const middleUp = middleTip < landmarks[10].y;
                const ringUp = ringTip < landmarks[14].y;
                const pinkyUp = pinkyTip < landmarks[18].y;
                const thumbUp = thumbTip < landmarks[2].y;
                
                const extendedFingers = [indexUp, middleUp, ringUp, pinkyUp].filter(f => f).length;
                
                // Peace sign (index + middle up, others down)
                const isPeace = indexUp && middleUp && !ringUp && !pinkyUp;
                
                // Rock sign (index + pinky up, others down)
                const isRock = indexUp && !middleUp && !ringUp && pinkyUp;
                
                // Thumbs up
                const isThumbsUp = thumbUp && !indexUp && !middleUp && !ringUp && !pinkyUp;
                
                // Fist (all fingers closed)
                const isFist = !indexUp && !middleUp && !ringUp && !pinkyUp;
                
                // OK sign (thumb and index pinched, others extended)
                const isOK = handData.pinch > 0.7 && middleUp && ringUp && pinkyUp;
                
                // Point (only index up)
                const isPoint = indexUp && !middleUp && !ringUp && !pinkyUp && !thumbUp;
                
                // Detect gesture
                let newGesture = 'wave';
                
                if (isOK) {
                    newGesture = 'ok';
                    gestureElement.textContent = 'Gesture: üëå OK';
                    targetScale = 0.5;
                    rotationSpeed = 0.05;
                } else if (isPeace) {
                    newGesture = 'peace';
                    gestureElement.textContent = 'Gesture: ‚úåÔ∏è Peace';
                    targetScale = 1.5;
                    rotationSpeed = 0.01;
                    colorHue = (colorHue + 2) % 360;
                } else if (isRock) {
                    newGesture = 'rock';
                    gestureElement.textContent = 'Gesture: ü§ò Rock';
                    targetScale = 1.8;
                    rotationSpeed = 0.03;
                    explosionActive = true;
                } else if (isThumbsUp) {
                    newGesture = 'thumbsup';
                    gestureElement.textContent = 'Gesture: üëç Thumbs Up';
                    targetScale = 1.2;
                    rotationSpeed = 0.015;
                } else if (isFist) {
                    newGesture = 'fist';
                    gestureElement.textContent = 'Gesture: ‚úä Fist';
                    targetScale = 0.2;
                    rotationSpeed = 0;
                    explosionActive = false;
                } else if (isPoint) {
                    newGesture = 'point';
                    gestureElement.textContent = 'Gesture: üëâ Point';
                    targetScale = 1.0;
                    rotationSpeed = 0.005;
                } else if (handData.pinch > 0.7) {
                    newGesture = 'pinch';
                    gestureElement.textContent = 'Gesture: ü§è Pinch';
                    targetScale = 0.3;
                    rotationSpeed = 0.002;
                } else if (handData.spread > 0.6) {
                    newGesture = 'spread';
                    gestureElement.textContent = 'Gesture: ‚úã Spread';
                    targetScale = 2.5;
                    rotationSpeed = 0.008;
                } else {
                    newGesture = 'wave';
                    gestureElement.textContent = 'Gesture: üëã Wave';
                    targetScale = 1;
                    rotationSpeed = 0.002;
                    explosionActive = false;
                }
                
                // Track gesture duration
                if (newGesture !== currentGesture) {
                    currentGesture = newGesture;
                    gestureStartTime = Date.now();
                }
                
                colorHue = (colorHue + 0.5) % 360;
            } else {
                handData.detected = false;
                gestureElement.textContent = 'Gesture: None';
                targetScale = 1;
                rotationSpeed = 0.002;
                explosionActive = false;
                currentGesture = 'none';
            }
        }

        // Animation loop
        let lastTime = performance.now();
        let frameCount = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            // FPS counter
            frameCount++;
            const now = performance.now();
            if (now - lastTime > 1000) {
                fpsElement.textContent = `FPS: ${frameCount}`;
                frameCount = 0;
                lastTime = now;
            }
            
            if (particleSystem) {
                // Smooth scale transition
                currentScale += (targetScale - currentScale) * 0.1;
                particleSystem.scale.set(currentScale, currentScale, currentScale);
                
                // Rotate based on hand position
                if (handData.detected) {
                    particleSystem.rotation.y += handData.x * 0.01 + rotationSpeed;
                    particleSystem.rotation.x += handData.y * 0.01;
                    particleSystem.position.x = handData.x * 0.5;
                    particleSystem.position.y = handData.y * 0.5;
                    
                    // Gesture-specific effects
                    const colors = particleSystem.geometry.attributes.color.array;
                    const positions = particleSystem.geometry.attributes.position.array;
                    
                    if (currentGesture === 'peace') {
                        // Rainbow wave effect
                        for (let i = 0; i < colors.length; i += 3) {
                            const h = (colorHue + (i / colors.length) * 360 + now * 0.1) % 360;
                            const c = new THREE.Color().setHSL(h / 360, 0.8, 0.6);
                            colors[i] = c.r;
                            colors[i + 1] = c.g;
                            colors[i + 2] = c.b;
                        }
                        particleSystem.geometry.attributes.color.needsUpdate = true;
                    } else if (currentGesture === 'rock' && explosionActive) {
                        // Explosion effect
                        for (let i = 0; i < positions.length; i += 3) {
                            const distance = Math.sqrt(
                                positions[i] * positions[i] +
                                positions[i + 1] * positions[i + 1] +
                                positions[i + 2] * positions[i + 2]
                            );
                            const expansion = Math.sin(now * 0.003) * 0.3;
                            positions[i] *= 1 + expansion * 0.01;
                            positions[i + 1] *= 1 + expansion * 0.01;
                            positions[i + 2] *= 1 + expansion * 0.01;
                        }
                        particleSystem.geometry.attributes.position.needsUpdate = true;
                        
                        // Red-orange color
                        for (let i = 0; i < colors.length; i += 3) {
                            const c = new THREE.Color().setHSL((10 + Math.random() * 40) / 360, 0.9, 0.6);
                            colors[i] = c.r;
                            colors[i + 1] = c.g;
                            colors[i + 2] = c.b;
                        }
                        particleSystem.geometry.attributes.color.needsUpdate = true;
                    } else if (currentGesture === 'ok') {
                        // Spiral effect
                        particleSystem.rotation.z += 0.03;
                        for (let i = 0; i < colors.length; i += 3) {
                            const c = new THREE.Color().setHSL(0.6, 0.8, 0.6);
                            colors[i] = c.r;
                            colors[i + 1] = c.g;
                            colors[i + 2] = c.b;
                        }
                        particleSystem.geometry.attributes.color.needsUpdate = true;
                    } else if (currentGesture === 'thumbsup') {
                        // Gold color
                        for (let i = 0; i < colors.length; i += 3) {
                            const c = new THREE.Color().setHSL(0.13, 0.9, 0.6);
                            colors[i] = c.r;
                            colors[i + 1] = c.g;
                            colors[i + 2] = c.b;
                        }
                        particleSystem.geometry.attributes.color.needsUpdate = true;
                    } else if (currentGesture === 'fist') {
                        // Compress and darken
                        for (let i = 0; i < colors.length; i += 3) {
                            colors[i] *= 0.95;
                            colors[i + 1] *= 0.95;
                            colors[i + 2] *= 0.95;
                        }
                        particleSystem.geometry.attributes.color.needsUpdate = true;
                    } else if (currentGesture === 'point') {
                        // Follow direction with beam effect
                        particleSystem.rotation.z = Math.sin(now * 0.002) * 0.2;
                    } else if (currentGesture === 'pinch') {
                        // Color shift
                        for (let i = 0; i < colors.length; i += 3) {
                            const c = new THREE.Color().setHSL((colorHue + i) / colors.length, 0.8, 0.6);
                            colors[i] = c.r;
                            colors[i + 1] = c.g;
                            colors[i + 2] = c.b;
                        }
                        particleSystem.geometry.attributes.color.needsUpdate = true;
                    }
                } else {
                    particleSystem.rotation.y += rotationSpeed;
                    particleSystem.rotation.z *= 0.95;
                    particleSystem.position.x *= 0.95;
                    particleSystem.position.y *= 0.95;
                }
            }
            
            renderer.render(scene, camera);
        }

        // Shape switching
        document.querySelectorAll('.btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentShape = btn.dataset.shape;
                createParticleSystem();
            });
        });

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Wait for all scripts to load
        window.addEventListener('load', () => {
            initThree();
            initHandTracking();
        });
    </script>
</body>
</html>
