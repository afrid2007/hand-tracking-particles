<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Particles (Fixed)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body { overflow: hidden; background: #000; font-family: sans-serif; user-select: none; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #webcam-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; opacity: 0; pointer-events: none; }
        #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
        
        /* Loading Screen */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white; z-index: 1000;
        }
        #loading-text { margin-bottom: 20px; font-size: 18px; }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333;
            border-top: 4px solid #00ff00; border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Error Box for Mobile Debugging */
        #error-log {
            display: none; position: absolute; top: 50px; left: 5%; width: 90%;
            background: rgba(255, 0, 0, 0.9); color: white; padding: 15px;
            border-radius: 10px; z-index: 2000; font-family: monospace; font-size: 12px;
        }

        /* Controls */
        #controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 30px;
            display: flex; gap: 15px; z-index: 100;
        }
        .btn {
            width: 45px; height: 45px; border-radius: 50%; border: none;
            background: #333; color: white; font-size: 20px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        .btn.active { background: #00ff00; color: black; transform: scale(1.1); }
        
        #instructions {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); color: white; padding: 25px; border-radius: 20px;
            text-align: center; z-index: 200; width: 80%; max-width: 300px;
        }
        #start-btn {
            margin-top: 20px; padding: 10px 30px; background: #00ff00; border: none;
            border-radius: 20px; font-weight: bold; font-size: 16px; cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="error-log"></div>

        <div id="loading">
            <div id="loading-text">Starting AI Engine...</div>
            <div class="spinner"></div>
            <div style="margin-top: 15px; font-size: 12px; color: #888;">Please allow camera access when asked</div>
        </div>
        
        <div id="webcam-container">
            <video id="webcam" playsinline></video>
        </div>
        
        <div id="overlay"></div>
        
        <div id="instructions">
            <h2 style="color:#00ff00; margin-bottom:15px">Hand Particles</h2>
            <p>1. Show your hand üëã</p>
            <p>2. Pinch index & thumb üëå</p>
            <p>3. Move to change colors üåà</p>
            <button id="start-btn">START EXPERIENCE</button>
        </div>
        
        <div id="controls">
            <button class="btn active" onclick="setTemplate('default')">‚óè</button>
            <button class="btn" onclick="setTemplate('hearts')">‚ô•</button>
            <button class="btn" onclick="setTemplate('stars')">‚òÖ</button>
            <button class="btn" onclick="setTemplate('fireworks')">‚ú®</button>
        </div>
    </div>

    <script>
        // 1. Error Handling System
        function showError(msg) {
            const el = document.getElementById('error-log');
            el.style.display = 'block';
            el.innerText = "ERROR: " + msg + "\n\n(Try refreshing or opening in Chrome)";
            document.getElementById('loading').style.display = 'none';
        }

        window.onerror = function(msg, url, line) {
            showError(`${msg} (Line ${line})`);
            return false;
        };

        // 2. Main Logic
        let scene, camera, renderer, particles, geometry;
        let hands, cameraUtils;
        let handDistance = 0, handX = 0;
        const particleCount = 800; // Lower count for better mobile FPS
        let currentTemplate = 'default';

        async function init() {
            try {
                // Setup Three.js
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
                camera.position.z = 5;

                renderer = new THREE.WebGLRenderer({ alpha: true, antialias: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('overlay').appendChild(renderer.domElement);

                createParticles();
                
                // Initialize MediaPipe Hands
                if (typeof Hands === 'undefined') {
                    throw new Error("MediaPipe library failed to load. Check internet.");
                }

                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 0, // 0 is fastest (Lite), 1 is Full
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onResults);

                // Start Camera
                const videoElement = document.getElementById('webcam');
                cameraUtils = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: 640,
                    height: 480
                });

                console.log("Starting camera...");
                await cameraUtils.start();
                
                // If we get here, everything loaded!
                document.getElementById('loading').style.display = 'none';
                animate();

            } catch (e) {
                console.error(e);
                showError(e.message);
            }
        }

        function createParticles() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                positions[i*3] = (Math.random() - 0.5) * 5;
                positions[i*3+1] = (Math.random() - 0.5) * 5;
                positions[i*3+2] = (Math.random() - 0.5) * 5;
                
                colors[i*3] = 0.5;
                colors[i*3+1] = 1.0;
                colors[i*3+2] = 0.5;
                
                sizes[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.2, vertexColors: true, transparent: true, opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const thumb = landmarks[4];
                const index = landmarks[8];

                // Calculate distance (pinch)
                const d = Math.sqrt(
                    Math.pow(thumb.x - index.x, 2) + 
                    Math.pow(thumb.y - index.y, 2)
                );
                
                // Smooth values
                handDistance += (d - handDistance) * 0.1;
                handX += (thumb.x - handX) * 0.1;

                updateParticles(true);
            } else {
                updateParticles(false);
            }
        }

        function updateParticles(handDetected) {
            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.color.array;
            const time = Date.now() * 0.001;
            const expansion = 1 + (handDistance * 8); // Pinch effect

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Base shapes
                let tx, ty, tz;
                const angle = (i / particleCount) * Math.PI * 2;
                
                if (currentTemplate === 'default') { // Sphere
                    const phi = Math.acos(-1 + (2 * i) / particleCount);
                    const r = 2 * expansion;
                    tx = r * Math.sin(phi) * Math.cos(angle);
                    ty = r * Math.sin(phi) * Math.sin(angle);
                    tz = r * Math.cos(phi);
                } 
                else if (currentTemplate === 'hearts') {
                    const r = expansion * 0.1;
                    tx = 16 * Math.pow(Math.sin(angle), 3) * r;
                    ty = (13 * Math.cos(angle) - 5 * Math.cos(2*angle) - 2 * Math.cos(3*angle)) * r;
                    tz = (Math.random() - 0.5) * 2;
                }
                else if (currentTemplate === 'stars') {
                    const r = (i % 5 === 0 ? 3 : 1.5) * expansion;
                    tx = Math.cos(angle * 5) * r;
                    ty = Math.sin(angle * 5) * r;
                    tz = (Math.random() - 0.5);
                }
                else { // Fireworks
                    const r = (Math.random() * 4) * expansion;
                    tx = Math.cos(angle) * r;
                    ty = Math.sin(angle) * r;
                    tz = (Math.random() - 0.5) * 2;
                }

                // Smoothly move particles to target
                positions[i3] += (tx - positions[i3]) * 0.05;
                positions[i3+1] += (ty - positions[i3+1]) * 0.05;
                positions[i3+2] += (tz - positions[i3+2]) * 0.05;

                // Color magic based on hand X position
                if (handDetected) {
                    const hue = (handX + (i * 0.001)) % 1;
                    const color = new THREE.Color().setHSL(hue, 1.0, 0.5);
                    colors[i3] = color.r;
                    colors[i3+1] = color.g;
                    colors[i3+2] = color.b;
                }
            }
            
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            // Auto rotate if no hand
            if (!handDetected) {
                particles.rotation.y += 0.005;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // UI Helpers
        window.setTemplate = (name) => {
            currentTemplate = name;
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        };

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start button logic (required for audio/video contexts on mobile)
        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('instructions').style.display = 'none';
            // Start init only after user gesture
            init();
        });

        // Initial loading setup
        document.getElementById('loading').style.display = 'none'; // Hide initially to show Start button
        document.getElementById('instructions').style.display = 'flex'; // Show instructions first
        
        // When they click START, we show loading then INIT
        document.getElementById('start-btn').onclick = function() {
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('loading').style.display = 'flex';
            init();
        }
    </script>
</body>
</html>
