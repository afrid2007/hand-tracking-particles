<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Gesture Particles</title>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body { background: #000; font-family: Arial, sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }
        #video { position: absolute; top: 10px; right: 10px; width: 160px; height: 120px; border: 2px solid #fff; border-radius: 8px; z-index: 10; }
        #controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 10; }
        .btn { background: rgba(255,255,255,0.2); border: 2px solid #fff; color: #fff; padding: 12px 20px; border-radius: 25px; cursor: pointer; font-size: 14px; backdrop-filter: blur(10px); transition: all 0.3s; }
        .btn:active { transform: scale(0.95); background: rgba(255,255,255,0.3); }
        .btn.active { background: rgba(100,200,255,0.5); border-color: #0af; }
        #info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; font-size: 12px; z-index: 10; max-width: 200px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 18px; text-align: center; z-index: 100; }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Loading Hand Tracking...</div>
        <video id="video" autoplay playsinline></video>
        <div id="info">
            <div>ðŸ‘‹ Show your hand to camera</div>
            <div id="gesture">Gesture: None</div>
            <div id="fps">FPS: 0</div>
        </div>
        <div id="controls">
            <button class="btn" data-shape="sphere">Sphere</button>
            <button class="btn active" data-shape="heart">Heart</button>
            <button class="btn" data-shape="flower">Flower</button>
            <button class="btn" data-shape="saturn">Saturn</button>
            <button class="btn" data-shape="firework">Firework</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        import * as THREE from 'three';

        // MediaPipe Hands setup
        const videoElement = document.getElementById('video');
        const loadingElement = document.getElementById('loading');
        const gestureElement = document.getElementById('gesture');
        const fpsElement = document.getElementById('fps');
        
        let scene, camera, renderer, particles, particleSystem;
        let handData = { detected: false, x: 0, y: 0, z: 0, pinch: 0, spread: 0 };
        let currentShape = 'heart';
        let targetScale = 1;
        let currentScale = 1;
        let colorHue = 0;

        const PARTICLE_COUNT = 5000;
        
        // Initialize Three.js
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);
            
            createParticleSystem();
            animate();
        }

        // Particle shape generators
        function generateShape(shape, count) {
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                let x, y, z, h;
                const i3 = i * 3;
                
                switch(shape) {
                    case 'heart':
                        const t = (i / count) * Math.PI * 2;
                        const u = Math.random() * 0.5;
                        x = u * (16 * Math.pow(Math.sin(t), 3)) * 0.05;
                        y = u * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.05;
                        z = (Math.random() - 0.5) * 0.5;
                        h = 0.95;
                        break;
                        
                    case 'flower':
                        const angle = (i / count) * Math.PI * 2 * 5;
                        const r = Math.random() * (0.5 + 0.3 * Math.sin(angle * 6));
                        x = r * Math.cos(angle);
                        y = r * Math.sin(angle);
                        z = (Math.random() - 0.5) * 0.3;
                        h = (i / count) * 0.3 + 0.5;
                        break;
                        
                    case 'saturn':
                        const phi = Math.random() * Math.PI * 2;
                        const theta = Math.random() * Math.PI;
                        const dist = Math.random() < 0.3 ? Math.random() * 2 : Math.random() * 0.6;
                        const isSphere = Math.random() < 0.3;
                        
                        if (isSphere) {
                            x = dist * Math.sin(theta) * Math.cos(phi) * 0.5;
                            y = dist * Math.sin(theta) * Math.sin(phi) * 0.5;
                            z = dist * Math.cos(theta) * 0.5;
                        } else {
                            x = dist * Math.cos(phi);
                            y = (Math.random() - 0.5) * 0.1;
                            z = dist * Math.sin(phi);
                        }
                        h = 0.55;
                        break;
                        
                    case 'firework':
                        const burst = Math.random();
                        const direction = Math.random() * Math.PI * 2;
                        const elevation = Math.random() * Math.PI;
                        const speed = burst * 2;
                        x = speed * Math.sin(elevation) * Math.cos(direction);
                        y = speed * Math.sin(elevation) * Math.sin(direction);
                        z = speed * Math.cos(elevation);
                        h = burst * 0.8;
                        break;
                        
                    default: // sphere
                        const p = Math.random() * Math.PI * 2;
                        const th = Math.random() * Math.PI;
                        const rd = Math.random() * 1.5;
                        x = rd * Math.sin(th) * Math.cos(p);
                        y = rd * Math.sin(th) * Math.sin(p);
                        z = rd * Math.cos(th);
                        h = Math.random();
                }
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                const color = new THREE.Color().setHSL(h, 0.8, 0.6);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            
            return { positions, colors };
        }

        function createParticleSystem() {
            if (particleSystem) {
                scene.remove(particleSystem);
            }
            
            const { positions, colors } = generateShape(currentShape, PARTICLE_COUNT);
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            particles = positions;
        }

        // MediaPipe Hands with CDN
        async function initHandTracking() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user', width: 640, height: 480 } 
                });
                videoElement.srcObject = stream;
                
                await new Promise(resolve => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        resolve();
                    };
                });
                
                // Load MediaPipe Hands
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
                script.onload = () => setupMediaPipe();
                document.head.appendChild(script);
                
            } catch (err) {
                console.error('Camera error:', err);
                loadingElement.textContent = 'Camera access denied';
            }
        }

        function setupMediaPipe() {
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults(onHandResults);
            
            const cam = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });
            cam.start();
            
            loadingElement.style.display = 'none';
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const thumb = landmarks[4];
                const index = landmarks[8];
                const middle = landmarks[12];
                const ring = landmarks[16];
                const pinky = landmarks[20];
                
                handData.detected = true;
                handData.x = (landmarks[9].x - 0.5) * 4;
                handData.y = -(landmarks[9].y - 0.5) * 3;
                handData.z = -landmarks[9].z * 5;
                
                // Calculate pinch (thumb-index distance)
                const pinchDist = Math.sqrt(
                    Math.pow(thumb.x - index.x, 2) +
                    Math.pow(thumb.y - index.y, 2)
                );
                handData.pinch = Math.max(0, 1 - pinchDist * 10);
                
                // Calculate spread (finger spread)
                const spread = Math.abs(index.x - pinky.x) + Math.abs(index.y - pinky.y);
                handData.spread = Math.min(spread * 3, 1);
                
                // Update gesture display
                if (handData.pinch > 0.7) {
                    gestureElement.textContent = 'Gesture: ðŸ¤ Pinch';
                    targetScale = 0.3;
                } else if (handData.spread > 0.6) {
                    gestureElement.textContent = 'Gesture: âœ‹ Spread';
                    targetScale = 2;
                } else {
                    gestureElement.textContent = 'Gesture: ðŸ‘‹ Wave';
                    targetScale = 1;
                }
                
                colorHue = (colorHue + 0.5) % 360;
            } else {
                handData.detected = false;
                gestureElement.textContent = 'Gesture: None';
                targetScale = 1;
            }
        }

        // Animation loop
        let lastTime = performance.now();
        let frameCount = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            // FPS counter
            frameCount++;
            const now = performance.now();
            if (now - lastTime > 1000) {
                fpsElement.textContent = `FPS: ${frameCount}`;
                frameCount = 0;
                lastTime = now;
            }
            
            if (particleSystem) {
                // Smooth scale transition
                currentScale += (targetScale - currentScale) * 0.1;
                particleSystem.scale.set(currentScale, currentScale, currentScale);
                
                // Rotate based on hand position
                if (handData.detected) {
                    particleSystem.rotation.y += handData.x * 0.01;
                    particleSystem.rotation.x += handData.y * 0.01;
                    particleSystem.position.x = handData.x * 0.5;
                    particleSystem.position.y = handData.y * 0.5;
                    
                    // Color shift on pinch
                    if (handData.pinch > 0.5) {
                        const colors = particleSystem.geometry.attributes.color.array;
                        for (let i = 0; i < colors.length; i += 3) {
                            const c = new THREE.Color().setHSL((colorHue + i) / colors.length, 0.8, 0.6);
                            colors[i] = c.r;
                            colors[i + 1] = c.g;
                            colors[i + 2] = c.b;
                        }
                        particleSystem.geometry.attributes.color.needsUpdate = true;
                    }
                } else {
                    particleSystem.rotation.y += 0.002;
                    particleSystem.position.x *= 0.95;
                    particleSystem.position.y *= 0.95;
                }
            }
            
            renderer.render(scene, camera);
        }

        // Shape switching
        document.querySelectorAll('.btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentShape = btn.dataset.shape;
                createParticleSystem();
            });
        });

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Load Camera script
        const cameraScript = document.createElement('script');
        cameraScript.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';
        cameraScript.onload = () => {
            initThree();
            initHandTracking();
        };
        document.head.appendChild(cameraScript);
    </script>
</body>
</html>
