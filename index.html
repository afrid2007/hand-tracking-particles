<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Gesture Particle System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body { overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        
        #video-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; }
        #video-feed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        #canvas-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        
        #controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                   background: rgba(0,0,0,0.7); padding: 10px; border-radius: 20px;
                   display: flex; gap: 8px; z-index: 100; }
        .btn { background: #333; color: white; border: none; width: 40px; height: 40px;
              border-radius: 50%; display: flex; align-items: center; justify-content: center;
              cursor: pointer; transition: all 0.2s; font-size: 12px; }
        .btn.active { background: #00ff00; color: black; transform: scale(1.1); }
        
        #status { position: absolute; top: 10px; left: 10px; color: white;
                 background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 15px;
                 font-size: 12px; z-index: 100; }
        
        #instructions { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                       color: white; background: rgba(0,0,0,0.9); padding: 20px; border-radius: 15px;
                       text-align: center; z-index: 200; max-width: 90%; }
        #instructions h3 { color: #00ff00; margin-bottom: 15px; }
        #instructions p { margin: 8px 0; font-size: 14px; line-height: 1.4; }
        #close-instructions { background: #00ff00; color: black; border: none; padding: 10px 20px;
                             border-radius: 20px; margin-top: 15px; font-weight: bold; cursor: pointer; }
        
        #permission-prompt { position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                           background: #000; display: flex; flex-direction: column;
                           justify-content: center; align-items: center; color: white; z-index: 300; }
        #permission-prompt button { background: #00ff00; color: black; border: none; padding: 15px 30px;
                                  border-radius: 30px; margin-top: 20px; font-size: 16px; font-weight: bold;
                                  cursor: pointer; }
    </style>
</head>
<body>
    <div id="permission-prompt">
        <h2>Camera Access Required</h2>
        <p>This app uses your camera for hand gesture tracking</p>
        <button id="start-camera">ALLOW CAMERA ACCESS</button>
    </div>
    
    <div id="video-container">
        <video id="video-feed" autoplay playsinline></video>
        <canvas id="canvas-overlay"></canvas>
        <div id="overlay"></div>
    </div>
    
    <div id="status">Initializing camera...</div>
    
    <div id="instructions">
        <h3>Hand Gesture Particle System</h3>
        <p>‚Ä¢ Show your hand to camera</p>
        <p>‚Ä¢ Pinch thumb & index finger to resize particles</p>
        <p>‚Ä¢ Move hand left/right to change colors</p>
        <p>‚Ä¢ Move hand up/down to switch templates</p>
        <button id="close-instructions">START</button>
    </div>
    
    <div id="controls">
        <button class="btn active" data-template="default">‚óè</button>
        <button class="btn" data-template="hearts">‚ô•</button>
        <button class="btn" data-template="stars">‚òÖ</button>
        <button class="btn" data-template="spiral">üåÄ</button>
        <button class="btn" data-template="fireworks">‚ú®</button>
    </div>

    <script>
        class HandGestureParticleSystem {
            constructor() {
                this.video = document.getElementById('video-feed');
                this.canvasOverlay = document.getElementById('canvas-overlay');
                this.ctx = this.canvasOverlay.getContext('2d');
                this.stream = null;
                
                // Three.js setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.z = 10;
                
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: false,
                    powerPreference: "low-power",
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.2));
                document.getElementById('overlay').appendChild(this.renderer.domElement);
                
                // Particle system
                this.particleCount = 800;
                this.currentTemplate = 'default';
                this.scale = 1;
                this.hue = 0;
                this.autoRotate = true;
                
                // Hand tracking simulation (since we can't use MediaPipe)
                this.handDetected = false;
                this.handX = 0.5;
                this.handY = 0.5;
                this.pinchDistance = 1;
                
                // Setup
                this.setupParticles();
                this.setupEventListeners();
                this.animate();
                
                // Start camera when user clicks
                document.getElementById('start-camera').addEventListener('click', () => {
                    this.initCamera();
                });
            }
            
            async initCamera() {
                try {
                    document.getElementById('status').textContent = 'Accessing camera...';
                    
                    // Request camera access
                    this.stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        } 
                    });
                    
                    this.video.srcObject = this.stream;
                    document.getElementById('permission-prompt').style.display = 'none';
                    document.getElementById('status').textContent = 'Camera ready - show hand';
                    
                    // Start hand tracking simulation
                    this.startHandTracking();
                    
                } catch(error) {
                    console.error('Camera error:', error);
                    document.getElementById('status').textContent = 'Camera access denied';
                    document.getElementById('permission-prompt').innerHTML = `
                        <h2>Camera Access Denied</h2>
                        <p>Please enable camera permissions and refresh</p>
                        <button onclick="location.reload()">REFRESH PAGE</button>
                    `;
                }
            }
            
            startHandTracking() {
                // Simulate hand tracking by analyzing video frames
                const processFrame = () => {
                    if (this.video.readyState === this.video.HAVE_ENOUGH_DATA) {
                        // Update canvas size
                        this.canvasOverlay.width = this.video.videoWidth;
                        this.canvasOverlay.height = this.video.videoHeight;
                        
                        // Draw video frame to canvas
                        this.ctx.drawImage(this.video, 0, 0, this.canvasOverlay.width, this.canvasOverlay.height);
                        
                        // Get image data for simple hand detection
                        const imageData = this.ctx.getImageData(0, 0, this.canvasOverlay.width, this.canvasOverlay.height);
                        this.analyzeFrame(imageData);
                    }
                    
                    requestAnimationFrame(processFrame);
                };
                
                processFrame();
            }
            
            analyzeFrame(imageData) {
                const { data, width, height } = imageData;
                let handPixels = 0;
                let totalPixels = width * height;
                let sumX = 0, sumY = 0;
                
                // Simple skin color detection (approximate)
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Basic skin tone detection (simplified)
                    if (r > 95 && g > 40 && b > 20 && 
                        r > g && r > b && 
                        Math.abs(r - g) > 15) {
                        
                        handPixels++;
                        const pixelIndex = i / 4;
                        const x = pixelIndex % width;
                        const y = Math.floor(pixelIndex / width);
                        
                        sumX += x;
                        sumY += y;
                    }
                }
                
                // If enough skin-colored pixels detected, consider hand present
                const handThreshold = totalPixels * 0.05; // 5% of screen
                this.handDetected = handPixels > handThreshold;
                
                if (this.handDetected) {
                    // Calculate average hand position
                    this.handX = sumX / handPixels / width;
                    this.handY = sumY / handPixels / height;
                    
                    // Simulate pinch detection based on hand position variance
                    this.pinchDistance = 0.5 + Math.abs(0.5 - this.handY) * 2;
                    this.scale = Math.max(0.3, Math.min(3, this.pinchDistance));
                    
                    // Color based on horizontal position
                    this.hue = this.handX;
                    
                    // Template based on vertical position
                    const templateIndex = Math.floor(this.handY * 5);
                    const templates = ['default', 'hearts', 'stars', 'spiral', 'fireworks'];
                    this.currentTemplate = templates[Math.min(4, Math.max(0, templateIndex))];
                    
                    // Update template button UI
                    document.querySelectorAll('.btn').forEach((btn, index) => {
                        btn.classList.remove('active');
                        if (index === templateIndex) {
                            btn.classList.add('active');
                        }
                    });
                    
                    document.getElementById('status').textContent = 'Hand detected - gestures active';
                } else {
                    document.getElementById('status').textContent = 'Show hand to camera';
                }
            }
            
            setupParticles() {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.particleCount * 3);
                const colors = new Float32Array(this.particleCount * 3);
                const sizes = new Float32Array(this.particleCount);
                
                for(let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    positions[i3] = 3 * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = 3 * Math.sin(phi) * Math.sin(theta);
                    positions[i3 + 2] = 3 * Math.cos(phi);
                    colors[i3] = 0.3; colors[i3 + 1] = 0.6; colors[i3 + 2] = 1.0;
                    sizes[i] = Math.random() * 1.2 + 0.5;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                this.particleSystem = new THREE.Points(geometry, material);
                this.scene.add(this.particleSystem);
                this.geometry = geometry;
            }
            
            setupEventListeners() {
                // Template buttons (fallback for manual control)
                document.querySelectorAll('.btn').forEach((button, index) => {
                    button.addEventListener('click', (e) => {
                        document.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        const templates = ['default', 'hearts', 'stars', 'spiral', 'fireworks'];
                        this.currentTemplate = templates[index];
                    });
                });
                
                // Close instructions
                document.getElementById('close-instructions').addEventListener('click', () => {
                    document.getElementById('instructions').style.display = 'none';
                });
                
                // Window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            updateParticles() {
                const positions = this.geometry.attributes.position.array;
                const colors = this.geometry.attributes.color.array;
                const sizes = this.geometry.attributes.size.array;
                
                for(let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3;
                    const angle = (i / this.particleCount) * Math.PI * 2;
                    const baseRadius = 3 * this.scale;
                    
                    switch(this.currentTemplate) {
                        case 'hearts':
                            const heartScale = 0.8 * this.scale;
                            const x = heartScale * 16 * Math.pow(Math.sin(angle), 3);
                            const y = heartScale * (13 * Math.cos(angle) - 5 * Math.cos(2 * angle));
                            positions[i3] = x * 0.05;
                            positions[i3 + 1] = y * 0.05;
                            positions[i3 + 2] = 0;
                            break;
                            
                        case 'stars':
                            const starAngle = angle;
                            const radius = (i % 2 === 0) ? baseRadius : baseRadius * 0.4;
                            positions[i3] = Math.cos(starAngle) * radius * 0.3;
                            positions[i3 + 1] = Math.sin(starAngle) * radius * 0.3;
                            positions[i3 + 2] = 0;
                            break;
                            
                        case 'spiral':
                            const spiralRadius = angle * 0.1 * this.scale;
                            positions[i3] = Math.cos(angle) * spiralRadius;
                            positions[i3 + 1] = Math.sin(angle) * spiralRadius;
                            positions[i3 + 2] = (angle * 0.05 * this.scale) - (Math.PI * this.scale);
                            break;
                            
                        case 'fireworks':
                            const fireworkAngle = Math.random() * Math.PI * 2;
                            const fireworkRadius = Math.random() * baseRadius;
                            positions[i3] = Math.cos(fireworkAngle) * fireworkRadius;
                            positions[i3 + 1] = Math.sin(fireworkAngle) * fireworkRadius;
                            positions[i3 + 2] = (Math.random() - 0.5) * baseRadius * 0.5;
                            break;
                            
                        default:
                            const theta = (i / this.particleCount) * Math.PI * 2;
                            const phi = Math.acos(1 - 2 * (i / this.particleCount));
                            positions[i3] = baseRadius * Math.sin(phi) * Math.cos(theta);
                            positions[i3 + 1] = baseRadius * Math.sin(phi) * Math.sin(theta);
                            positions[i3 + 2] = baseRadius * Math.cos(phi);
                    }
                    
                    const hueValue = (this.hue + (i / this.particleCount) * 0.3) % 1;
                    const [r, g, b] = this.hslToRgb(hueValue, 0.8, 0.6);
                    colors[i3] = r; colors[i3 + 1] = g; colors[i3 + 2] = b;
                    sizes[i] = (Math.random() * 1.2 + 0.5) * this.scale;
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
            }
            
            hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) return [l, l, l];
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1; if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q; if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                return [hue2rgb(p, q, h + 1/3), hue2rgb(p, q, h), hue2rgb(p, q, h - 1/3)];
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updateParticles();
                
                if (this.handDetected) {
                    this.autoRotate = false;
                    this.particleSystem.rotation.y = this.handX * Math.PI * 2;
                    this.particleSystem.rotation.x = this.handY * Math.PI;
                } else if (this.autoRotate) {
                    this.particleSystem.rotation.y += 0.005;
                    this.particleSystem.rotation.x += 0.002;
                }
                
                this.camera.position.x = Math.sin(Date.now() * 0.0005) * 0.5;
                this.camera.lookAt(this.scene.position);
                
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            new HandGestureParticleSystem();
        });
    </script>
</body>
</html>
